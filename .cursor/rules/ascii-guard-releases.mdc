# ascii-guard Release Process

When the user says "Release ascii-guard" or similar:

## CRITICAL: Python Environment Management

**THIS PROJECT USES pyenv + venv FOR ISOLATION:**

### Rules for AI Agents:

1. **NEVER install packages in pyenv global Python**
   - The pyenv global environment MUST remain pristine (only `pip`)
   - All development packages MUST be in `.venv` only

2. **ALWAYS use `.venv` for package operations**
   - ❌ NEVER run: `pip install <package>`
   - ✅ ALWAYS run: `.venv/bin/pip install <package>` OR activate venv first
   - ❌ NEVER run: `python -m pytest` (uses system Python)
   - ✅ ALWAYS run: `.venv/bin/python -m pytest` (uses venv Python)

3. **Check venv exists before operations**
   ```bash
   if [[ ! -d .venv ]]; then
       echo "ERROR: Virtual environment not found!"
       echo "Run: ./setup-venv.sh"
       exit 1
   fi
   ```

4. **Pre-commit hooks are configured to use .venv explicitly**
   - `.pre-commit-config.yaml` uses `.venv/bin/python` paths
   - No manual venv activation needed for commits
   - If pre-commit fails with import errors, venv is broken - rebuild it

5. **If you need to install a package for testing:**
   ```bash
   .venv/bin/pip install <package>  # Correct
   # NOT: pip install <package>     # Wrong!
   ```

6. **User has `PIP_REQUIRE_VIRTUALENV=true` set**
   - This prevents accidental global installs
   - If you see "Could not find an activated virtualenv" - this is GOOD
   - It means you're trying to pollute global Python (don't do it!)

**Why this matters:**
- During task #24 we polluted pyenv global with pytest/pytest-cov
- This broke pre-commit hooks (ascii_guard not in global)
- Task #29 cleaned this up and hardened the setup
- We must never repeat this mistake

---

## Step 0: MANDATORY CI/CD Check (ALWAYS DO THIS FIRST)

**BEFORE STARTING ANY RELEASE - CHECK CI/CD STATUS:**

```bash
gh run list --limit 1
```

**If ANY workflow shows `failure` or `in_progress`:**
- **STOP IMMEDIATELY** - Do NOT start release preparation
- Politely inform user: "CI/CD is currently failing. Cannot proceed with release until all checks pass."
- Show which workflows failed: `gh run list --limit 5`
- Ask user to fix CI/CD errors first
- Wait for user confirmation that CI/CD is fixed before proceeding

**Only proceed if:**
- Latest workflow shows: `completed` + `success`
- No workflows are currently `in_progress`

**During release preparation (after any commits):**
- Monitor CI/CD: `gh run list --limit 3`
- Wait for workflows to complete
- Check status before proceeding to next step
- If failures occur: STOP and report

**NEVER:**
- Bypass CI/CD failures with manual workarounds
- Proceed with release if CI/CD is failing
- Use `--no-verify` on release-related commits
- Ignore or work around GitHub Actions errors

**Why this matters:**
- CI/CD failures indicate code quality issues
- Releasing broken code to PyPI is irreversible
- Users depend on package quality
- Automated tests are the last line of defense

---

## CRITICAL: Error Handling During Releases

**ZERO TOLERANCE FOR ERRORS DURING RELEASE PROCESS**

### Rule: STOP on ANY Error

Once a release process has started (from Step 1 onwards), **EVERY ERROR MUST STOP THE PROCESS IMMEDIATELY**.

**When an error occurs:**

1. **STOP** - Do NOT continue with workarounds
2. **REPORT** - Clearly communicate:
   - What command failed
   - What the error message says
   - What step of the release process you were in
3. **DISCUSS** - Ask user: "An error occurred during release. How should we proceed?"
4. **WAIT** - Do NOT make assumptions or try fixes without approval

### What Counts as an Error

**Examples of errors that MUST stop the process:**
- `pyenv: version 'X.Y' is not installed`
- `No module named 'build'`
- `pre-commit hook failed`
- `gh: command not found`
- `git push` failed
- Package build failed
- Any Python exception or traceback
- Any non-zero exit code from release commands
- CI/CD workflow failures after commits

### What NOT to Do

**NEVER:**
- Work around errors with manual commands
- Skip steps to "fix it later"
- Use alternative methods without discussion
- Modify files manually to bypass issues
- Continue hoping "it will work out"
- Create manual GitHub releases
- Upload to PyPI manually
- Force push without approval

### What TO Do

**ALWAYS:**
- Report the error immediately and clearly
- Stop all release activities
- Explain what the error means
- Propose systematic fixes (not workarounds)
- Wait for user approval before implementing fixes
- Document the error and fix in task notes
- Verify fix works before retrying release

### Example Error Response

**Bad Response:**
```
Error: pyenv version not found. Let me work around this...
[proceeds to manually build package]
```

**Good Response:**
```
❌ ERROR: Release process stopped

Command failed: python3 -m build
Error: pyenv: version '3.12' is not installed

This error occurred during Step 4 (Execute Release).

Root cause: System doesn't have Python 3.12 installed.

We need to fix this before continuing the release. Options:
A) Install Python 3.12: pyenv install 3.12
B) Cancel release and create task to fix environment

How would you like to proceed?
```

### Recovery Process

If release is stopped due to errors:

1. **Document**: Create task for fixing the error properly
2. **Rollback**: If needed, rollback any partial release state
3. **Fix**: Address root cause systematically
4. **Test**: Verify fix with dry-run
5. **Retry**: Start fresh release attempt

**Remember: A delayed release is better than a broken release.**

---

## Step 1: Generate AI Release Summary

- Review commit messages to understand changes since last release
- Write 2-3 paragraph summary highlighting key improvements
- Focus on user-facing benefits and why this release matters
- Keep it human-readable (no commit lists, no technical jargon)
- Save to `release/AI_RELEASE_SUMMARY.md`

### Example AI Summary

```markdown
This release introduces comprehensive ASCII art box detection and auto-fixing
capabilities for documentation files. The linter now accurately identifies
misaligned corners, borders, and box-drawing characters across multiple
Unicode styles, ensuring consistent visual formatting.

Key improvements include a powerful CLI interface with both lint and fix
modes, zero-dependency architecture using only Python standard library, and
extensive test coverage. The tool integrates seamlessly with CI/CD pipelines
via pre-commit hooks.

Users can now maintain clean, professional documentation with automatically
aligned ASCII art boxes, eliminating manual character-by-character adjustments
and improving overall documentation quality.
```

## Step 2: Prepare Release

```bash
./release/release.sh --prepare
```

**What it does:**
- Analyzes commits since last release
- Determines version bump (major/minor/patch) automatically
- Reads AI summary from `release/AI_RELEASE_SUMMARY.md`
- Generates complete release notes in `release/RELEASE_NOTES.md` (summary + categorized commits)
- Displays preview and saves prepare state

**Output:**
- `release/RELEASE_NOTES.md` (complete release notes - **THIS IS WHAT GETS REVIEWED**)
- `release/.prepare_state` (metadata for execute step)

**After this step:**
- Prompt user to review `release/RELEASE_NOTES.md`
- Tell them they can edit it if needed
- Inform them about version override option if they want to change it

## Step 3: Review & Edit Release Notes (IMPORTANT)

**CRITICAL: Between prepare and execute, the human can/should:**
1. Edit the generated release notes
2. Override the version number if desired

### Where Are the Notes?

**TWO files are used in the release process:**

1. **`release/AI_RELEASE_SUMMARY.md`** - AI-written summary (Step 1)
   - Written by AI in Step 1
   - Just the 2-3 paragraph summary, no commits
   - Can be edited before running prepare
   - Input to the prepare process

2. **`release/RELEASE_NOTES.md`** - Complete release notes (Step 2)
   - Generated by prepare script
   - Contains: AI summary + categorized commits
   - **THIS IS THE FILE TO REVIEW/EDIT** before execute

### How to Edit

**Option 1: Edit AI Summary Before Prepare**
```bash
# Edit the AI-written summary before running prepare
vim release/AI_RELEASE_SUMMARY.md
./release/release.sh --prepare
```

**Option 2: Edit Release Notes After Prepare (RECOMMENDED)**
```bash
# Edit the complete release notes after prepare
vim release/RELEASE_NOTES.md
./release/release.sh --execute
```

**Option 3: Override Version Number**

If the human wants a specific version (e.g., "This should be 1.0.0"):

```bash
./release/release.sh --set-version 1.0.0
# Then execute
./release/release.sh --execute
```

**Natural Language Triggers:**
- "change version to 1.0.0"
- "make this version 2.0.0"
- "set version to 1.5.0"
- "this should be version 1.0.0"

**What it does:**
- Validates format (X.Y.Z)
- Validates new version > current version
- Updates prepare state
- Updates release/RELEASE_NOTES.md header
- Logs the override

### Common Edits

- Remove commits that shouldn't be in release notes
- Regroup commits into different categories
- Rewrite commit messages for clarity
- Add context or explanations
- Improve AI summary wording

## Step 4: Execute Release

```bash
./release/release.sh --execute
```

**What it does:**
1. Updates version in `pyproject.toml` and `src/ascii_guard/__init__.py`
2. Builds Python package (`python -m build`)
3. Commits version changes and release notes
4. Creates git tag `vX.Y.Z`
5. Pushes tag and main branch to GitHub
6. **GitHub Actions takes over:**
   - Runs full test suite
   - Publishes to PyPI (trusted publishing)
   - Creates GitHub release with wheel/sdist artifacts
7. Cleans up working files
8. Commits release log

**Result:** Release is initiated, GitHub Actions completes publishing

---

## Complete Workflow Example

```bash
# 1. AI writes summary
# (AI creates release/AI_RELEASE_SUMMARY.md with 2-3 paragraphs)

# 2. Prepare
./release/release.sh --prepare
# (Reads AI summary, adds commits, writes release/RELEASE_NOTES.md)

# 3. Review and optionally edit release notes
vim release/RELEASE_NOTES.md  # THIS is the file to edit!

# Optional: Override version
./release/release.sh --set-version 1.0.0

# 4. Execute
./release/release.sh --execute
# (Updates version, builds, tags, pushes - GitHub Actions publishes)
```

---

## Key GitHub Actions Integration

**CRITICAL DIFFERENCE from ocroot:**
- ascii-guard does **NOT** publish to PyPI directly from release.sh
- Instead, pushing the tag triggers GitHub Actions workflow (`.github/workflows/release.yml`)
- GitHub Actions uses **trusted publishing** (no PyPI tokens needed)
- This ensures:
  - Tests run before publishing
  - Secure publishing without local credentials
  - Consistent CI/CD process

**Workflow after execute:**
1. `release.sh --execute` pushes tag `vX.Y.Z`
2. GitHub Actions `release.yml` is triggered by tag push
3. GitHub Actions builds package
4. GitHub Actions runs tests
5. GitHub Actions publishes to PyPI (trusted publishing via OIDC)
6. GitHub Actions creates GitHub release with wheel and sdist

**Monitor release:**
- GitHub Actions: https://github.com/fxstein/ascii-guard/actions
- PyPI: https://pypi.org/project/ascii-guard/
- GitHub Releases: https://github.com/fxstein/ascii-guard/releases

---

## Safeguards

**❌ NEVER DO THIS:**
- Do NOT modify `release/release.sh` logic to filter commits
- Do NOT add skip conditions to the release script
- Do NOT change the release process code
- Do NOT attempt to publish to PyPI manually (GitHub Actions does this)
- Do NOT push tags manually (use the script)

**✅ ALWAYS DO THIS:**
- ALWAYS create AI summary in `release/AI_RELEASE_SUMMARY.md` first
- ALWAYS run prepare before execute
- ALWAYS wait for human review before execute
- ALWAYS let the human edit `release/RELEASE_NOTES.md` if they want
- ALWAYS verify GitHub CLI is authenticated (`gh auth status`)
- ALWAYS check build dependencies are installed (`python -m build`, available)

**Editing release notes is MANUAL TEXT EDITING, not code changes.**

---

## Error Handling

### Common Issues

**Error: "Release not prepared"**
- Solution: Run `./release/release.sh --prepare` first

**Error: "Uncommitted changes detected"**
- Solution: Commit or stash all changes before releasing
- Exception: Release working files are automatically excluded

**Error: "Invalid version format"**
- Solution: Use X.Y.Z format (e.g., 1.0.0, 0.2.5)

**Error: "New version must be greater than current"**
- Solution: Ensure new version > current version

**Error: "Package build failed"**
- Solution: Ensure `python -m build` is installed: `pip install build`
- Check pyproject.toml is valid

**Error: "gh not authenticated"**
- Solution: Run `gh auth login`

---

## Version Numbering

ascii-guard uses [Semantic Versioning](https://semver.org/):

### Automatic Detection

The script analyzes commit messages:

```bash
# MAJOR bump triggers (X.0.0)
feat!: ...          # Breaking feature
fix!: ...           # Breaking fix
BREAKING CHANGE:    # Explicit breaking change

# MINOR bump triggers (0.X.0)
feat: ...           # New feature
feature: ...        # New feature (alt)

# PATCH bump triggers (0.0.X)
fix: ...            # Bug fix
chore: ...          # Maintenance
docs: ...           # Documentation
refactor: ...       # Code refactoring
```

### Manual Override

If automatic detection doesn't match your intent:

```bash
./release/release.sh --set-version 1.0.0
```

---

## Files and Tracking

### What Gets Committed

| File | When | Why |
|------|------|-----|
| `release/AI_RELEASE_SUMMARY.md` | During execute | Audit trail: what AI wrote |
| `release/RELEASE_NOTES.md` | During execute | Audit trail: what was reviewed |
| `release/RELEASE_SUMMARY.md` | During execute | Historical record |
| `release/RELEASE_LOG.log` | After execute | Operational audit log |
| `pyproject.toml` | During execute | Version updated |
| `src/ascii_guard/__init__.py` | During execute | Version updated |

### What Gets Deleted

| File | When | Why |
|------|------|-----|
| `release/AI_RELEASE_SUMMARY.md` | After execute | Working file, already committed |
| `release/RELEASE_NOTES.md` | After execute | Working file, already committed |
| `release/.prepare_state` | After execute | Temporary metadata |
| `dist/` | After execute | Build artifacts |
| `build/` | After execute | Build cache |

### What's Gitignored

- `dist/`
- `build/`
- `*.egg-info/`
- `release/.prepare_state`

---

## AI Agent Workflow

### When User Says "Release ascii-guard"

1. **Generate AI Summary:**
   ```markdown
   I'll help you release ascii-guard. First, let me create a release summary.

   [Write 2-3 paragraph summary about what changed and why it matters]

   Saved to: release/AI_RELEASE_SUMMARY.md
   ```

2. **Run Prepare:**
   ```bash
   ./release/release.sh --prepare
   ```

3. **Show Preview and Wait:**
   ```markdown
   Release preview prepared:
   - Version: 0.1.0 → 0.2.0
   - Type: minor release
   - Release notes: release/RELEASE_NOTES.md

   Please review release/RELEASE_NOTES.md and let me know:
   - Should I proceed with execute?
   - Do you want to edit the release notes?
   - Do you want to change the version number?
   ```

4. **Handle User Response:**
   - If "execute" → Run `./release/release.sh --execute`
   - If "change version to X.Y.Z" → Run `./release/release.sh --set-version X.Y.Z`
   - If "edit notes" → Open `release/RELEASE_NOTES.md` in editor

5. **After Execute:**
   ```markdown
   ✅ Release v0.2.0 initiated successfully!

   GitHub Actions is now:
   - Building and testing the package
   - Publishing to PyPI (trusted publishing)
   - Creating GitHub release

   Monitor progress:
   - GitHub Actions: [link]
   - PyPI (when complete): [link]
   - GitHub Release: [link]
   ```

---

**Remember: Release notes editing = text editing, NOT code changes.**
**GitHub Actions handles PyPI publishing automatically via trusted publishing.**
